<!DOCTYPE html>
<html>
  <head>
    <style type="text/css">
@import url('https://fonts.googleapis.com/css?family=Dosis');

body {
    color: white;
    font-family: Verdana, Geneva, Tahoma, sans-serif;
}

a, a:hover, a:visited, a:active {
    color: lightblue;
}

.remark-slide-number {
    visibility: hidden;
}

.remark-slide-content {
    background-color: #282828;
}

.remark-slide-content h1 {
    font-size: 1.7em;
    margin-bottom: 0.5em;
}

.remark-slide-content h2 {
    font-size: 1.4em;
    margin-bottom: 0.2em;
}

.remark-slide-content table {
    border-collapse: collapse;
}

.remark-slide-content table td, .remark-slide-content table th {
    border: 1px solid black;
    padding: 0.5em;
}

    </style>
  </head>
  <body>
     <textarea id="source">
class: center, middle

# Libp2p - zkSummit

## Power to the peers

<div style="position: absolute; bottom: 5%; left: 0; right: 0;">
    <div style="text-align: center">
        <img src="parity-logo.png" alt="Parity" height="128" />
    </div>
</div>
<div style="position: absolute; bottom: 5%; left: 5%;">
.left[
    <img src="twitter.png" alt="Twitter" height="16" /> twitter.com/tomaka17<br />
    <img src="github.png" alt="GitHub" height="16" /> github.com/tomaka<br />
]
</div>
<div style="position: absolute; bottom: 5%; right: 5%;">
.right[
    github.com/Vurich <img src="github.png" alt="GitHub" height="16" /><br />
]
</div>
---

# What is libp2p?

- Peer-to-peer networking protocol
- Implementations in Go, JavaScript and Rust (us!)
- Used by IPFS
- Will be used by Polkadot and Parity
- Possibly by Ethereum in the future (discussions are open)

<div style="position: absolute; bottom: 5%; left: 5%;">
.left[
    <img src="ipfs.png" alt="IPFS" height="64" />
]
</div>
<div style="position: absolute; bottom: 5%; left: 0; right: 0;">
    <div style="text-align: center">
        <img src="polkadot.png" alt="Polkadot" height="64" />
    </div>
</div>
<div style="position: absolute; bottom: 5%; right: 5%;">
.right[
    <img src="parity-logo.png" alt="Parity" height="64" />
]
</div>
---

# Multiaddress

In traditional peer-to-peer systems, a node is contacted through an IP address, a TCP port
and an UDP port.

In libp2p, a node is contacted through a *multiaddress*.

Examples:

- `/ip4/80.129.4.75/tcp/8200`
- `/ip4/196.27.207.12/tcp/10250/ws`
- `/ip6/2001:db8:a0b:12f0::1/udp/3050`
- `/dns/example.com/tcp/5000`
- `/ip4/125.90.85.23/tcp/5000/p2p-circuit/ip4/90.2.98.122/tcp/9001`

**Note**: Nodes can communicate with each other entirely through WebSockets, meaning that we can
run a JavaScript or WASM node inside a browser.

---

# Protocol negotiation

Once a connection between two nodes is established, the dialer negotiates with the listener a
protocol to apply to the connection.

Example communications between two nodes:

<img src="multistream-select.png" alt="" />

In this example, we negotiate the protocol `/plaintext/1.0.0`, then the protocol `/mplex/6.7.0`.

---

# Encryption layer

The first protocol negotiated when a connection is open is the security layer.

Two protocols exist:
- *plaintext*, a basic pass-through protocol. Useful for debugging.
- *secio*, that provides full encryption.

## Secio

Standard Diffie-Hellman key exchange.

The cipher, hash function, and key exchange algorithm are not hardcoded in the protocol, and are
also negotiated between the two nodes during the *secio* handshake.

---

# Multiplexing

On top of the security layer, the second protocol that is negotiated is the multiplexing layer.

Three protocols exist:
- *mplex*
- *yamux* (only implemented in Go)
- *spdy* (only implemented in JavaScript)

<div style="text-align:center">
    <img src="multiplexing.svg" alt="" />
</div>

Multiplexing allows both nodes to open multiple substreams on a single connection, where each of
these substreams uses a different protocol and is treated as if it was separate connection.

---

# Final protocols

In each multiplexed substream, a final protocol is negotiated.

Example of some commonly-supported protocols:

- *identify*
- *ping*
- *kademlia*
- *floodsub*
- etc.

Or you can also create your own protocol, which is often what you want.

Example:

- IPFS uses the *bitswap* protocol.
- Polkadot, Parity and Ethereum would also use their own custom protocol.

---

# Protocol detail: identify

Whenever a dialer connects to a listener, the listener immediately sends back information about
itself.

These information include:

- The public key of the node (useful if secio isn't used).
- The multiaddresses the node is listening on.
- The protocols a node supports.
- The version of the client the node uses.
- The "global" protocol that the node wants (eg. "ipfs", "polkadot")

**Note**: A common situation is that A dials B, then B opens a multiplexed substream to A and
negotiates the *identify* protocol on it. It is then A that sends information about itself to B,
allowing B to learn about A.

---

# Interlude: Multihash

The ID of a node is not tied to any specific algorithm and instead is provided in the *multihash*
format.

---

# Protocol detail: floodsub

Publish-subscribe protocol.

The *floodsub* protocol allows you to broadcast messages over the network. A node can send a
message to another node through this protocol, and the message will then be broadcasted to all the
other nodes it is connected to.

Each message has a topic. Nodes subscribe to specific topics and only receive messages that match
the topic they are registered to.

Example usages:

- Messages in a chat application.
- Broadcasting new blocks in a blockchain.

Messages can be signed in order to prove the author.

---

# Protocol detail: kademlia

Kademlia is a Distributed Hash Table (DHT).

A DHT is similar to a traditional hash table, except that each node only stores a subset of the
entries. The entries that a node stores are determined based on its public key.

Each node that supports kademlia manages two DHTs: one for information about peers, and one for
arbitrary records that any node of the network can insert. These arbitrary records expire after a
while.

When a node joins the network, it notifies the nodes it connects to in order to get inserted in
the peers' hash table.

---

# Designing a small chat application

Let's write a small peer-to-peer application that allows all the members of the network to chat
together.

How it all plugs together:

- When they start, nodes have absolutely no idea how to access other nodes. In order to be able to
  function, we need to have a list of *bootstrap nodes*.
- When a node starts, it generates a key pair for itself or loads an existing key pair from the
  disk.
- It then uses the Kademlia protocol in order to discover nodes whose IDs are near its own key
  pair. This process involves connecting to some of the boostrap nodes, opening the Kademlia
  protocol. TODO: meh
- It will then connect to a certain number of closest nodes and open the *floodsub* protocol.
- Any message received from any of these nodes through *floodsub* will be printed to stdout.
  Anything received by stdin will be broadcasted as a message to all the network connected through
  *floodsub*.

---
class: center, middle

# Walkthrough with rust-libp2p

Let's build this chat application with rust-libp2p.

https://github.com/libp2p/rust-libp2p

**Warning**: the code below doesn't exactly match the current API because the library is still
being adjusted.

Demo code can be found here: TODO

---

# Walkthrough #1: Initialization

Nodes have two modes: bootstrap, or not.

We create what is called a *peerstore*, and store the bootstrap node in it (unless we are the
bootstrap node). The *peerstore* is a database of node information.

```rust
let bootstrap_peer_id = ...;        // some hardcoded value

let peer_store = Arc::new(MemoryPeerstore::empty());
if !is_bootstrap {
    peer_store
        .peer_or_create(&bootstrap_peer_id)
        .add_addr("/ip4/127.0.0.1/tcp/10101".parse().unwrap(),
                Duration::from_secs(3600 * 24 * 365));
}

let my_peer_id = if is_bootstrap {
    bootstrap_peer_id
} else {
    let key = (0..2048).map(|_| rand::random::<u8>())
                       .collect::<Vec<_>>();
    PeerId::from_public_key(&key)
};
```

---

# Walkthrough #2: Build the transport

We build the object the represents how we are able to access other nodes.

The code below builds a *transport* that allows WebSockets over TCP/IP, or regular TCP/IP, and
with on top of it *plaintext* and *mplex*.

We put an *IdentifyTransport* around the transport, so that nodes that connections to nodes are
automatically identified and the node IDs determined and stored in the `peer_store`.

```rust
let mut core = tokio_core::reactor::Core::new().unwrap();
let raw = WsConfig::new(TcpConfig::new(core.handle()))
    .or_transport(TcpConfig::new(core.handle()))
    .with_upgrade(PlainTextConfig)
    .with_upgrade(MplexConfig)
    .into_connection_reuse());
let transport = IdentifyTransport::new(raw, peer_store.clone());
```

---

# Walkthrough #3: prepare the final protocols configuration

We prepare the configuration for the final protocols that the server will handle: *identify*,
*kademlia* and *floodsub*.

```rust
// Floodsub
let (floodsub, fs_rx) = FloodSubUpgrade::new(my_peer_id.clone());

// Kademlia
let kad_cfg = KademliaConfig {
    parallelism: 3,
    peer_store: peer_store,
    local_peer_id: my_peer_id.clone(),
    timeout: Duration::from_secs(2),
};
let kad_ctl_proto = KademliaControllerPrototype::new(kad_cfg);
let kad_upgrade = KademliaUpgrade::from_prototype(&kad_ctl_proto);

// Final
let protocols_configuration = ConnectionUpgrader {
    kad: kad_upgrade,
    identify: libp2p_identify::IdentifyProtocolConfig,
    floodsub: floodsub.clone(),
};
```

---

# Walkthrough #4: build the swarm

We now create what is called a *swarm*. This is the object that will manage all the active
connections.

```rust
let (swarm_controller, swarm_future) = libp2p_swarm::swarm(
    transport, protocols_configuration, |upgrade, client_addr| {
        match upgrade {
            Protocol::Kad(kad) => Box::new(kad) as Box<_>,
            Protocol::FloodSub(future) => {
                Box::new(future) as Box<_>
            },
            Protocol::Identify(id) => {
                match id {
                    IdentifyOutput::Sender { sender, .. }) => {
                        sender.send(build_local_identify_info(),
                                    &client_addr)
                    },
                    IdentifyOutput::RemoteInfo { .. } => {
                        unreachable!()
                    },
                }
            }
        }
    },
);
```

---

# Walkthrough #5: start listening

We ask the `swarm_controller` to start listening for incoming connections.

```rust
let addr: Multiaddr = if is_bootstrap {
    "/ip4/0.0.0.0/tcp/10101".parse().unwrap()
} else {
    "/ip4/0.0.0.0/tcp/0".parse().unwrap()
};

let actual_addr = swarm_controller.listen_on(addr.clone())
    .expect("failed to listen to multiaddress");
info!("Now listening on {}", actual_addr);
```

---

# Walkthrough #6: subscribe to a floodsub topic

Having a `swarm_controller` makes it possible to perform actions on the network.

Let's subscribe to a *floodsub* topic. This will tell everyone we are connected to (ie. nobody for
now) and will connect to, that we want to receive messages for this topic.

```rust
let topic = TopicBuilder::new("chat").build();
let floodsub_ctl = {
    FloodSubController::new(&floodsub_upgrade,
                            swarm_controller.clone())
};
floodsub_ctl.subscribe(&topic);
```

---

# Walkthrough #7: perform a Kademlia node find

We use the `swarm_controller` to perform a Kademlia node find, and connect to all the nodes that
are closest to ours.

```rust
let (kad_controller, kad_init) =
    kad_ctl_proto.start(swarm_controller.clone());
let finished_enum = kad_controller
    .find_node(my_peer_id.clone())
    .and_then(move |out| {
        let local_hash = U512::from(my_peer_id.hash());
        for n in out {
            let addr = AddrComponent::P2P(n.into_bytes()).into();
            let _ = swarm_controller.dial_to_handler(addr,
                                        floodsub_upgrade.clone());
        }
        Ok(())
    });
```

---

# Walkthrough #8: sending and receiving messages

Whenever a message arrives on stdin, we dispatch it:

```rust
let stdin = spawn_stdin_stream_unbounded()
    .for_each(move |msg| {
        ... // The actual code is long because we need to
            // handle line breaks
        floodsub_ctl.publish(&topic, msg.into_bytes());
        Ok(())
    });
```

Whenever a message is received through floodsub, we write it to stdout:

```rust
let floodsub_rx = floodsub_rx.for_each(|msg| {
    if let Ok(msg) = String::from_utf8(msg.data) {
        info!("< {}", msg);
    }
    Ok(())
});
```

---

# Walkthrough 9: group everything and run

Rust-libp2p is fully asynchronous. Everything we did so far only performs initializations,
and doesn't actually do anything. We now start everything.

This is done by grouping everything into one `final_future`, and running it:

```rust
let final_future = swarm_future
    .select(floodsub_rx)
        .map_err(|(err, _)| err).map(|((), _)| ())
    .select(stdin)
        .map_err(|(err, _)| err).map(|((), _)| ())
    .select(finished_enum)
        .map_err(|(err, _)| err).and_then(|((), n)| n)
    .select(kad_init)
        .map_err(|(err, _)| err).and_then(|((), n)| n);

core.run(final_future).unwrap();
```

**Note**: This code is very tokio-heavy and thus can be confusing if you're not familiar with
this library.

---

# Misc: running the same code in the browser

The same code can be compiled for asmjs or wasm and run in the browser.

A few adjustements are required:

- Building the `transport`, as we cannot use TCP/IP.
- Running the final future is more complicated because of the cooperating threading model used
  by JavaScript (see http://bit.ly/2FZU3wQ).

Other than that, it's just:

```sh
cargo b --target=asmjs-unknown-emscripten
```

Or:

```sh
cargo b --target=wasm32-unknown-emscripten
```

---
class: center, middle

# Demo time?

Demo code can be found here: TODO

---
class: center, middle

# Thank you!

<div style="position: absolute; bottom: 5%; left: 0; right: 0;">
    <div style="text-align: center">
        <img src="parity-logo.png" alt="Parity" height="128" />
    </div>
</div>
<div style="position: absolute; bottom: 5%; left: 5%;">
.left[
    <img src="twitter.png" alt="Twitter" height="16" /> twitter.com/tomaka17<br />
    <img src="github.png" alt="GitHub" height="16" /> github.com/tomaka<br />
]
</div>
<div style="position: absolute; bottom: 5%; right: 5%;">
.right[
    github.com/Vurich <img src="github.png" alt="GitHub" height="16" /><br />
]
</div>
    </textarea>
     <script src="remark.min.js">
    </script>
    <script>
       var slideshow = remark.create();
    </script>
  </body>
</html>
